<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neuro-Genesis: Prism War</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #050505;
            overflow: hidden;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: none; /* Ocultar cursor nativo */
        }

        canvas {
            display: block;
        }

        /* HUD Holográfico */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #4fd1c5;
            pointer-events: none;
            text-shadow: 0 0 10px #4fd1c5;
            font-weight: bold;
            z-index: 10;
        }

        #score { font-size: 24px; letter-spacing: 2px; }
        #weapon-level { font-size: 14px; color: #faf089; margin-top: 5px; text-transform: uppercase; }
        #stats { font-size: 12px; color: #fff; opacity: 0.7; margin-top: 5px; }

        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 100%);
            box-shadow: inset 0 0 50px rgba(255, 0, 80, 0.1);
            z-index: 5;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.9);
            color: #fff;
            z-index: 20;
            transition: opacity 0.5s;
            cursor: pointer;
        }

        h1 {
            font-size: 40px;
            text-transform: uppercase;
            background: linear-gradient(to right, #4fd1c5, #fff, #ff0055);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 10px 0;
            animation: glitch 1s infinite alternate;
        }

        p { font-size: 14px; opacity: 0.7; letter-spacing: 1px; text-align: center; }

        @keyframes glitch {
            0% { text-shadow: 2px 0 #ff0055, -2px 0 #4fd1c5; }
            100% { text-shadow: -2px 0 #ff0055, 2px 0 #4fd1c5; }
        }
        
        /* Efecto de daño */
        .damage-flash {
            animation: flashRed 0.2s ease-out;
        }
        @keyframes flashRed {
            0% { box-shadow: inset 0 0 100px red; }
            100% { box-shadow: none; }
        }
    </style>
</head>
<body>

    <div id="vignette"></div>
    <div id="hud">
        <div id="score">SCORE: 0</div>
        <div id="weapon-level">SYSTEM: STANDBY</div>
        <div id="stats">SPEED: 100%</div>
    </div>

    <div id="start-overlay">
        <h1>PRISM WAR</h1>
        <p>ERES EL TRIÁNGULO GIRATORIO</p>
        <p>MANTÉN PULSADO PARA DISPARAR</p>
        <p>TOCA PARA INICIAR SISTEMAS</p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        /**
         * AUDIO SYNTH (Arcade Style)
         */
        const AudioSys = {
            ctx: null,
            masterGain: null,
            
            init() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
            },

            playShoot(pitch = 1) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(880 * pitch, t);
                osc.frequency.exponentialRampToValueAtTime(110, t + 0.1);
                
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(t + 0.1);
            },

            playExplosion() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.3);
                
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(t + 0.3);
            },

            playPowerUp() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, t);
                osc.frequency.linearRampToValueAtTime(880, t + 0.1);
                osc.frequency.linearRampToValueAtTime(1760, t + 0.3);
                
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(t + 0.3);
            },

            playCollect(type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'triangle';
                const baseFreq = type === 'gold' ? 880 : 660;
                
                osc.frequency.setValueAtTime(baseFreq, t);
                osc.frequency.linearRampToValueAtTime(baseFreq * 1.5, t + 0.1);
                
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(t + 0.4);
            }
        };

        /**
         * GAME ENGINE
         */
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const weaponEl = document.getElementById('weapon-level');
        const statsEl = document.getElementById('stats');
        const overlay = document.getElementById('start-overlay');

        let width, height;
        let frames = 0;
        let score = 0;
        let gameActive = false;
        
        // Entidades
        let player;
        let projectiles = [];
        let enemies = [];
        let particles = [];
        let powerups = [];
        let shake = 0; // Screen shake

        // Configuración de Armas
        const WEAPONS = [
            { name: "PULSO SIMPLE", rate: 15, color: '#4fd1c5', type: 0 },
            { name: "FUEGO DOBLE", rate: 12, color: '#63b3ed', type: 1 },
            { name: "TRIDENTE", rate: 10, color: '#faf089', type: 2 },
            { name: "CAOS OMNI", rate: 6, color: '#ff0055', type: 3 }
        ];

        class Player {
            constructor() {
                this.x = width / 2;
                this.y = height / 2;
                this.angle = 0;
                this.size = 20;
                this.weaponLevel = 0;
                this.xp = 0;
                this.nextLevelXp = 50;
                this.color = '#4fd1c5';
                this.fireTimer = 0;
                this.speedMultiplier = 1.0; // Incremento de Silver
            }

            update(mouseX, mouseY, firing) {
                // Movimiento suave hacia el mouse (Lerp)
                this.x += (mouseX - this.x) * 0.15;
                this.y += (mouseY - this.y) * 0.15;
                
                // Rotación constante
                this.angle += firing ? 0.3 : 0.05;

                // Límites
                this.x = Math.max(this.size, Math.min(width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(height - this.size, this.y));

                // Disparo
                if (firing) {
                    this.fireTimer++;
                    const weapon = WEAPONS[this.weaponLevel];
                    // Calcular tasa de fuego efectiva (menor es más rápido)
                    const effectiveRate = Math.max(2, Math.floor(weapon.rate / this.speedMultiplier));
                    
                    if (this.fireTimer % effectiveRate === 0) {
                        this.shoot(weapon);
                    }
                } else {
                    this.fireTimer = 0;
                }
            }

            shoot(weapon) {
                AudioSys.playShoot(1 + (this.weaponLevel * 0.2) + (this.speedMultiplier * 0.1));
                
                const spawnProjectile = (angleOffset) => {
                    projectiles.push(new Projectile(
                        this.x, 
                        this.y, 
                        this.angle + angleOffset, 
                        weapon.color
                    ));
                };

                if (weapon.type === 0) { // Simple
                    spawnProjectile(0);
                } else if (weapon.type === 1) { // Doble
                    spawnProjectile(-0.2);
                    spawnProjectile(0.2);
                } else if (weapon.type === 2) { // Triple
                    spawnProjectile(0);
                    spawnProjectile(-0.3);
                    spawnProjectile(0.3);
                } else if (weapon.type === 3) { // Omni
                    for(let i=0; i<8; i++) spawnProjectile((Math.PI*2/8) * i);
                }
                
                // Retroceso visual
                shake = 2 + this.weaponLevel;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Dibujar Triángulo
                ctx.beginPath();
                ctx.moveTo(this.size, 0);
                ctx.lineTo(-this.size/2, this.size/2);
                ctx.lineTo(-this.size/2, -this.size/2);
                ctx.closePath();
                
                ctx.fillStyle = '#000';
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                
                // Glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                
                ctx.fill();
                ctx.stroke();

                // Núcleo central
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI*2);
                ctx.fill();
                
                // Escudo visual (anillo XP)
                ctx.beginPath();
                ctx.arc(0, 0, this.size + 10, 0, Math.PI*2 * (this.xp / this.nextLevelXp));
                ctx.strokeStyle = `rgba(255, 255, 255, 0.5)`;
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            gainXp(amount) {
                this.xp += amount;
                if (this.xp >= this.nextLevelXp) {
                    this.levelUp();
                }
            }
            
            levelUp() {
                if (this.weaponLevel < WEAPONS.length - 1) {
                    this.weaponLevel++;
                    this.xp = 0;
                    this.nextLevelXp *= 1.5;
                    this.color = WEAPONS[this.weaponLevel].color;
                    AudioSys.playPowerUp();
                    this.updateHUD();
                    // Explosion visual de nivel
                    for(let i=0; i<30; i++) {
                        particles.push(new Particle(this.x, this.y, this.color, 8));
                    }
                    createFloatingText("WEAPON UPGRADE!", this.x, this.y - 30, '#fff');
                } else {
                    score += 1000;
                    this.xp = 0;
                    createFloatingText("MAX POWER BONUS!", this.x, this.y - 30, '#ff0055');
                }
            }

            collectPowerUp(type) {
                AudioSys.playCollect(type);
                if (type === 'silver') {
                    // SILVER: Aumenta velocidad de disparo incrementalmente
                    this.speedMultiplier += 0.15; // +15% velocidad
                    if (this.speedMultiplier > 3.0) this.speedMultiplier = 3.0; // Cap
                    
                    createFloatingText("SPEED UP!", this.x, this.y - 40, '#c0c0c0');
                    // Efecto visual
                    for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#c0c0c0', 5));
                } else if (type === 'gold') {
                    // GOLD: Sube de nivel inmediatamente
                    this.gainXp(this.nextLevelXp);
                    createFloatingText("GOLD POWER!", this.x, this.y - 40, '#ffd700');
                    // Efecto visual
                    for(let i=0; i<15; i++) particles.push(new Particle(this.x, this.y, '#ffd700', 6));
                }
                this.updateHUD();
            }

            updateHUD() {
                weaponEl.innerText = `SISTEMA: ${WEAPONS[this.weaponLevel].name}`;
                weaponEl.style.color = this.color;
                statsEl.innerText = `SPEED: ${Math.floor(this.speedMultiplier * 100)}%`;
            }

            takeDamage() {
                if (this.weaponLevel > 0) {
                    this.weaponLevel--;
                    this.xp = 0;
                    this.color = WEAPONS[this.weaponLevel].color;
                    this.speedMultiplier = Math.max(1.0, this.speedMultiplier - 0.5); // Perder velocidad al ser golpeado
                    this.updateHUD();
                    
                    weaponEl.innerText = `DAÑO CRÍTICO: ${WEAPONS[this.weaponLevel].name}`;
                    weaponEl.style.color = 'red';
                    shake = 20;
                    document.body.classList.add('damage-flash');
                    setTimeout(() => document.body.classList.remove('damage-flash'), 200);
                    
                    // Empuje de emergencia
                    enemies.forEach(e => {
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < 200) e.markedForDeletion = true;
                    });
                } else {
                    // Game Over Soft Reset
                    score = Math.max(0, score - 500);
                    this.speedMultiplier = 1.0;
                    this.updateHUD();
                    shake = 30;
                    weaponEl.innerText = "ALERTA: ESCUDOS BAJOS";
                }
            }
        }

        class PowerUp {
            constructor(type) {
                this.type = type; // 'silver' or 'gold'
                this.x = Math.random() * (width - 40) + 20;
                this.y = Math.random() * (height - 40) + 20;
                this.size = 12;
                this.life = 600; // 10 segundos a 60fps
                this.markedForDeletion = false;
                this.pulse = 0;
            }
            
            update() {
                this.life--;
                if (this.life <= 0) this.markedForDeletion = true;
                this.pulse += 0.1;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                const scale = 1 + Math.sin(this.pulse) * 0.2;
                ctx.scale(scale, scale);
                
                ctx.beginPath();
                if (this.type === 'gold') {
                    // Gold: Rombo
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(this.size, 0);
                    ctx.lineTo(0, this.size);
                    ctx.lineTo(-this.size, 0);
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700';
                } else {
                    // Silver: Círculo
                    ctx.arc(0, 0, this.size, 0, Math.PI*2);
                    ctx.fillStyle = '#c0c0c0';
                    ctx.shadowColor = '#ffffff';
                }
                
                // Desvanecerse cuando queda poco tiempo
                if (this.life < 100 && Math.floor(this.life/10)%2===0) {
                     ctx.globalAlpha = 0.2;
                }
                
                ctx.shadowBlur = 15;
                ctx.fill();
                
                // Borde blanco
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, angle, color) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * 15;
                this.vy = Math.sin(angle) * 15;
                this.color = color;
                this.markedForDeletion = false;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.markedForDeletion = true;
                }
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI*2);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Enemy {
            constructor() {
                if (Math.random() < 0.5) {
                    this.x = Math.random() < 0.5 ? -20 : width + 20;
                    this.y = Math.random() * height;
                } else {
                    this.x = Math.random() * width;
                    this.y = Math.random() < 0.5 ? -20 : height + 20;
                }
                
                this.size = Math.random() * 10 + 10;
                this.speed = Math.random() * 2 + 1;
                this.color = `hsl(${Math.random()*60 + 320}, 100%, 50%)`; 
                this.markedForDeletion = false;
                this.angle = 0;
            }

            update(player) {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;
                this.angle += 0.1;
                
                const dist = Math.hypot(this.x - player.x, this.y - player.y);
                if (dist < this.size + player.size) {
                    player.takeDamage();
                    this.markedForDeletion = true;
                    this.explode();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.beginPath();
                ctx.rect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.5;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
            }

            explode() {
                AudioSys.playExplosion();
                for(let i=0; i<8; i++) {
                    particles.push(new Particle(this.x, this.y, this.color, Math.random() * 3 + 1));
                }
            }
        }

        class Particle {
            constructor(x, y, color, speed) {
                this.x = x;
                this.y = y;
                this.color = color;
                const a = Math.random() * Math.PI * 2;
                this.vx = Math.cos(a) * speed;
                this.vy = Math.sin(a) * speed;
                this.life = 1;
                this.decay = Math.random() * 0.05 + 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        let floatingTexts = [];
        function createFloatingText(text, x, y, color) {
            floatingTexts.push({ text, x, y, color, life: 1.0 });
        }

        // INPUT
        const mouse = { x: width/2, y: height/2, active: false };
        
        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            const startHandler = () => {
                if (!gameActive) {
                    gameActive = true;
                    AudioSys.init();
                    overlay.style.opacity = 0;
                    setTimeout(() => overlay.style.display = 'none', 500);
                    player = new Player();
                    animate();
                }
            };
            
            overlay.addEventListener('mousedown', startHandler);
            overlay.addEventListener('touchstart', startHandler);

            window.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });
            window.addEventListener('mousedown', () => mouse.active = true);
            window.addEventListener('mouseup', () => mouse.active = false);

            window.addEventListener('touchmove', e => {
                e.preventDefault();
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
            }, {passive: false});
            window.addEventListener('touchstart', e => {
                e.preventDefault();
                mouse.active = true;
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
            }, {passive: false});
            window.addEventListener('touchend', () => mouse.active = false);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if(player) {
                player.x = width/2;
                player.y = height/2;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            let shakeX = 0, shakeY = 0;
            if (shake > 0) {
                shakeX = (Math.random() - 0.5) * shake;
                shakeY = (Math.random() - 0.5) * shake;
                shake *= 0.9;
                if(shake < 0.5) shake = 0;
            }

            ctx.save();
            ctx.translate(shakeX, shakeY);

            ctx.fillStyle = 'rgba(5, 5, 10, 0.3)';
            ctx.fillRect(-shakeX, -shakeY, width, height); 

            if (gameActive) {
                frames++;

                // Enemy Spawn
                const spawnRate = Math.max(20, 60 - Math.floor(score / 200));
                if (frames % spawnRate === 0) {
                    enemies.push(new Enemy());
                }

                // PowerUp Spawn (Raro)
                // Silver: ~1 cada 8 segundos (0.2%)
                if (Math.random() < 0.002) powerups.push(new PowerUp('silver'));
                // Gold: ~1 cada 30 segundos (0.05%)
                if (Math.random() < 0.0005) powerups.push(new PowerUp('gold'));

                // Player
                player.update(mouse.x, mouse.y, mouse.active);
                player.draw();

                // Projectiles
                projectiles.forEach((p, index) => {
                    p.update();
                    p.draw();
                    if (p.markedForDeletion) projectiles.splice(index, 1);
                });

                // Enemies
                enemies.forEach((e, eIndex) => {
                    e.update(player);
                    e.draw();

                    projectiles.forEach((p, pIndex) => {
                        const dist = Math.hypot(p.x - e.x, p.y - e.y);
                        if (dist < e.size + 4) { 
                            e.explode();
                            e.markedForDeletion = true;
                            p.markedForDeletion = true;
                            score += 50;
                            player.gainXp(20);
                            scoreEl.innerText = `SCORE: ${score}`;
                            shake = 2;
                        }
                    });
                });
                
                // PowerUps
                powerups.forEach((pu, index) => {
                    pu.update();
                    pu.draw();
                    
                    const dist = Math.hypot(player.x - pu.x, player.y - pu.y);
                    if (dist < player.size + pu.size) {
                        player.collectPowerUp(pu.type);
                        pu.markedForDeletion = true;
                    }

                    if (pu.markedForDeletion) powerups.splice(index, 1);
                });

                enemies = enemies.filter(e => !e.markedForDeletion);
                projectiles = projectiles.filter(p => !p.markedForDeletion);

                // Particles
                particles.forEach((p, index) => {
                    p.update();
                    p.draw();
                    if (p.life <= 0) particles.splice(index, 1);
                });

                // Floating Texts
                floatingTexts.forEach((ft, index) => {
                    ft.y -= 1;
                    ft.life -= 0.02;
                    
                    ctx.fillStyle = ft.color;
                    ctx.font = "bold 16px Arial";
                    ctx.globalAlpha = Math.max(0, ft.life);
                    ctx.fillText(ft.text, ft.x, ft.y);
                    ctx.globalAlpha = 1;

                    if (ft.life <= 0) floatingTexts.splice(index, 1);
                });
            }
            
            ctx.restore();
        }

        init();

    </script>
</body>
</html>
